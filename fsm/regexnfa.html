<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Regex - NFA Equivalence</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../styles.css" />
        <script type="text/javascript" src="../scripts/shCore.js"></script>
        <script type="text/javascript" src="../scripts/shBrushBash.js"></script>
        <script type="text/javascript" src="../scripts/shBrushCpp.js"></script>
        <script type="text/javascript" src="../scripts/shBrushCSharp.js"></script>
        <script type="text/javascript" src="../scripts/shBrushCss.js"></script>
        <script type="text/javascript" src="../scripts/shBrushDelphi.js"></script>
        <script type="text/javascript" src="../scripts/shBrushDiff.js"></script>
        <script type="text/javascript" src="../scripts/shBrushGroovy.js"></script>
        <script type="text/javascript" src="../scripts/shBrushJava.js"></script>
        <script type="text/javascript" src="../scripts/shBrushJScript.js"></script>
        <script type="text/javascript" src="../scripts/shBrushPhp.js"></script>
        <script type="text/javascript" src="../scripts/shBrushPlain.js"></script>
        <script type="text/javascript" src="../scripts/shBrushPython.js"></script>
        <script type="text/javascript" src="../scripts/shBrushRuby.js"></script>
        <script type="text/javascript" src="../scripts/shBrushScala.js"></script>
        <script type="text/javascript" src="../scripts/shBrushSql.js"></script>
        <script type="text/javascript" src="../scripts/shBrushVb.js"></script>
        <script type="text/javascript" src="../scripts/shBrushXml.js"></script>
        <link type="text/css" rel="stylesheet" href="lecture-notes.css"/>
        <link type="text/css" rel="stylesheet" href="../styles/shCore.css"/>
        <link type="text/css" rel="stylesheet" href="../styles/shThemeDefault.css"/>
        <script type="text/javascript">
            //SyntaxHighlighter.config.clipboardSwf = 'scripts/clipboard.swf';
            SyntaxHighlighter.defaults['toolbar'] = false;
            SyntaxHighlighter.defaults['auto-links'] = false;
 
            SyntaxHighlighter.all();
        </script>
</head>

<body>
 
<div id="container">
<div id="header"><h1>Formal Languages and Automata<img align="right" src="../logo-dark.png" alt="Amrita"> </h1> </div>
  <div id="wrapper">
    <div id="content">

<table align="right">
  <td align="left"><a href="regex.html">Prev</a></td>
  <td align="right"><a href="regulargrammar.html">Next</a></td>
</table>

<h2>Regex - NFA Equivalence</h2>

<p>We have seen how to construct DFAs, NFAs, &epsilon;-NFAS and regular expressions for various problems 
so far. We also established the equivalence of DFA and NFA/&epsilon;-NFA by showing an algorithmic approach 
to convert it into its equivalent DFA. We noted that it is easier to specify a NFA/&epsilon;-NFA compared to 
DFA. And it is even easier to specify a regular expression compared to NFA.</p>

<p>Now, we will show the equivalence of regular expression and DFA/NFA/&epsilon;-NFA by converting regular 
expression to its equivalent NFA. And we can see that the strings generated by the language defined a 
regular expression are exactly the strings accepted its equivalent NFA. As earlier, we will do this with an
example.</p>

<h3>Strings ending with abb. &Sigma; = {a, b}.</h3>

<p>The regular expression is given as: (a+b)* abb. Lets turn this into an &epsilon;-NFA. We will first design
a NFA for each symbol and then combine them systematically using &epsilon; transitions.</p>

<table border="1">
  <tr align="center" style="background: lightgray">
    <td><b>Regular Expression</b></td>
    <td><b>Equivalent NFA</b></td>
  </tr>
  <tr>
    <td>a</td>
    <td><img src="images/rna.png"></td>
  </tr>
  <tr>
    <td>b</td>
    <td><img src="images/rnb.png"></td>
  </tr>
  <tr>
    <td>a+b</td>
    <td><img src="images/rnaplusb.png"></td>
  </tr>
  <tr>
    <td>(a+b)*</td>
    <td><img src="images/rnaplusbstar.png"></td>
  </tr>
  <tr>
    <td>abb</td>
    <td><img src="images/rnabb.png"></td>
  </tr>
  <tr>
    <td>(a+b)* abb</td>
    <td><img src="images/rnaplusbstarabb.png"></td>
  </tr>
</table><br><br>

<p>The obtained &epsilon;-NFA accepts the language generated by the regular expression (a+b)*abb.
The &epsilon;-NFA can be converted to DFA in the same manner described in NFA-DFA equivalence and
minimized to its smallest DFA using DFA minimization algorithm already discussed. This is one way
to ascertain that the DFA obtained is the same.</p>

<p><b>To summarize,</b></p>
<ul>
  <p>1. Concatenation (binary . operation) is achieved by adding an &epsilon;-transition from the final 
  state of first NFA (which now ceases to be the final state) to the initial state of the second NFA.</p>

  <p>2. Alternation (binary + operation) is achieved by adding a new start state and a new final state. 
  The new start state connects to the start states of both NFAS by &epsilon;-transitions and the final 
  states of both the NFAs connect to the new final state by &epsilon;-transitions. Note that the old start 
  and final states cease to be start and final states anymore.</p>

  <p>3. Kleene star (unary *) is achieved by adding two &epsilon;-transitions: one from the start state of 
  the NFA to the final state and another from the final state of the NFA back to the start state.</p>

  <p>4. Unary <sup>+</sup> operation is achieved by adding a single &epsilon;-transition from the final state 
  to the start state (to facilitate one are more times).</p>

  <p>5. Unary ? operation is achieved by adding on &epsilon;-transition from start state to the final state 
  (to facilitate zero or one time).</p>
</ul>

<p style="color: blue"><b>DFA, NFA, &epsilon;-NFA and regular expressions 
are equivalent in power in describing regular languages.</b></p>

<p>As exercises, you can pick and convert some complex regular expressions discussed in the previous section.
Also, to get a complete practice, you can further convert the obtained &epsilon;-NFA to DFA to minimal DFA.
This will give a firm command over all the topics discussed thus far.</p>

    </div>
  </div>

  <div id="navigation">
  <p><br><strong><a href="../index.html">Home</a></strong></p>
    <ul>
      <li><a href="fsm.html">Finite State Machines</a></li>
      <li><a href="dfa.html">Deterministic Finite Automata (DFA)</a></li>
      <li><a href="dfaapplications.html">DFA Applications</a></li>
      <li><a href="dfaminimization.html">DFA Minimization</a></li>
      <li><a href="nfa.html">Non-deterministic Finite Automata (NFA)</a></li>
      <li><a href="nfadfa.html">NFA - DFA Equivalence</a></li>
      <li><a href="regex.html">Regular Expressions</a></li>
      <li><a href="regexnfa.html">Regexp - NFA Equivalence</a></li>
      <li><a href="regulargrammar.html">Regular Grammar (RG)</a></li>
      <li><a href="rgnfa.html">RG - NFA Equivalence</a></li>
      <li><a href="rlproperties.html">Properties of Regular Languages</a></li>
      <li><a href="pumpinglemma.html">Pumping Lemma for Regular Languages</a></li>
      <li><a href="lexer.html">FSM Application: Lexical Analysis</a></li>
      <li><a href="jlex.pdf">JLex: A Lexical Analyzer Generator</a></li>
  </div>

  <div id="extra">
  </div>
  <div id="footer", align="right">
    <p>Send your suggestions/comments to swaminathanj@am.amrita.edu</p>
  </div>
</div>
</body>
</html>

</body>
