<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Properties of Regular Languages</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../styles.css" />
        <script type="text/javascript" src="../scripts/shCore.js"></script>
        <script type="text/javascript" src="../scripts/shBrushBash.js"></script>
        <script type="text/javascript" src="../scripts/shBrushCpp.js"></script>
        <script type="text/javascript" src="../scripts/shBrushCSharp.js"></script>
        <script type="text/javascript" src="../scripts/shBrushCss.js"></script>
        <script type="text/javascript" src="../scripts/shBrushDelphi.js"></script>
        <script type="text/javascript" src="../scripts/shBrushDiff.js"></script>
        <script type="text/javascript" src="../scripts/shBrushGroovy.js"></script>
        <script type="text/javascript" src="../scripts/shBrushJava.js"></script>
        <script type="text/javascript" src="../scripts/shBrushJScript.js"></script>
        <script type="text/javascript" src="../scripts/shBrushPhp.js"></script>
        <script type="text/javascript" src="../scripts/shBrushPlain.js"></script>
        <script type="text/javascript" src="../scripts/shBrushPython.js"></script>
        <script type="text/javascript" src="../scripts/shBrushRuby.js"></script>
        <script type="text/javascript" src="../scripts/shBrushScala.js"></script>
        <script type="text/javascript" src="../scripts/shBrushSql.js"></script>
        <script type="text/javascript" src="../scripts/shBrushVb.js"></script>
        <script type="text/javascript" src="../scripts/shBrushXml.js"></script>
        <link type="text/css" rel="stylesheet" href="lecture-notes.css"/>
        <link type="text/css" rel="stylesheet" href="../styles/shCore.css"/>
        <link type="text/css" rel="stylesheet" href="../styles/shThemeDefault.css"/>
        <script type="text/javascript">
            //SyntaxHighlighter.config.clipboardSwf = 'scripts/clipboard.swf';
            SyntaxHighlighter.defaults['toolbar'] = false;
            SyntaxHighlighter.defaults['auto-links'] = false;
 
            SyntaxHighlighter.all();
        </script>
</head>

<body>
 
<div id="container">
<div id="header"><h1>Formal Languages and Automata<img align="right" src="../logo-dark.png" alt="Amrita"> </h1> </div>
  <div id="wrapper">
    <div id="content">

<table align="right">
  <td align="left"><a href="rgnfa.html">Prev</a></td>
  <td align="right"><a href="pumpinglemma.html">Next</a></td>
</table>


<h2>Properties of Regular Languages</h2>

<p>So far we have seen different ways of specifying regular language: DFA, NFA, &epsilon;-NFA, regular
expressions and regular grammar. We noted that all these different expressions are equal in power by
showing the equivalences. Regular expressions and grammars are considered as generators of regular
language while the machines (DFA, NFA, &epsilon;-NFA) are considered as acceptors of the language.</p>

<p>Now we will look at the properties of regular language. The properties can be broadly classified as
two parts: (A) Closure properties and (B) Decision properties</p>

<h2>(A) Closure Properties</h2>

<h3>1. Complementation</h3>

<p><b style="color: blue">If a language L is regular its complement L' is regular.</b></p>

<p>Let DFA(L) denote the DFA for the language L. Modify the DFA as follows to obtain DFA(L').</p>
<ol>
  <li>Change the final states to non-final states.</li>
  <li>Change the non-final states to final states.</li>
</ol>

<p>Since there exists a DFA(L') now, L' is regular.</p>

<p>This can be shown by an example using a DFA. Let L denote the language containing strings that begins
and ends with a. &Sigma; = {a, b}. The DFA for L is given below.</p>

<table>
  <tr>
    <td><img src="images/pstartsandendswitha.png"></td>
    <td>
      <ul>
        <p style="color: blue">Note: q<sub>3</sub> denotes the dead state.<br>
        Once you enter q<sub>3</sub>, you remain in it forever.</p>
      </ul>
    </td>
  </tr>
</table>

<p>L' denotes the language that does not contain strings that begin and end with a. This implies L'
contains strings that</p>
<ul>
  <li>begins with a and ends with b</li>
  <li>begins with b and ends with a</li>
  <li>begins with b and ends with b</li>
</ul>

<p>The DFA for L' is obtained by flipping the final states of DFA(L) to non-final states and vice-versa.
The DFA for L' is given below.</p>

<table>
  <tr>
    <td><img src="images/pdoesnotstartandendwitha.png"></td>
    <td>
      <ul>
        <li>q<sub>0</sub> ensures &epsilon; is accepted</li> <br>
        <li>q<sub>1</sub> ensures all strings that begin with a and end with b are accepted.</li> <br>
        <li>q<sub>3</sub> ensures all strings that begin with b (ending with either a or b) are accepted.</li>
      </ul>
    </td>
  </tr>
</table>

<p><b>Important Note</b>: While specifying the DFA for L, we have also included the dead state q<sub>3</sub>. 
It is important to include the dead state(s) if we are going to derive the complement DFA since, the dead 
state(s) too would become final in the complementation. If we didn't add the dead state(s) originally, the 
complement will not accept all strings supposed to be accepted.</p>

<p>In the above example, if we didn't include q<sub>3</sub> originally, the complement will not accept 
strings starting with b. It will only accept strings that begin with a and end with b which is only a 
subset of the complement.</p>

<p><b>CONCLUSION: REGULAR LANGUAGES ARE CLOSED UNDER COMPLEMENTATION.</b></p>

<h3>2. Union</h3>

<p><b style="color: blue">If L<sub>1</sub> and L<sub>2</sub> are regular, then L<sub>1</sub> &cup;
L<sub>2</sub> is regular.</b></p>

<p>This is easier proved using regular expressions. If L<sub>1</sub> is regular, there exists a regular
expression R1 to describe it. Similarly, if L<sub>2</sub> is regular, there exists a regular expression
R2 to describe it. R1 + R2 denotes the regular expression that describe L<sub>1</sub> &cup; L<sub>2</sub>.
Therefore, L<sub>1</sub> &cup; L<sub>2</sub> is regular.</p>

<p>This again can be shown using an example. If L<sub>1</sub> is a language that contains strings that 
begin with a and L<sub>2</sub> is a language that contain strings that end with a, then L<sub>1</sub> 
&cup; L<sub>2</sub> denotes the language the contain strings that either begin with a or end with a.</p>

<ul>
  <p>- a(a+b)* is the regular expression that denotes L<sub>1</sub>.</p>
  <p>- (a+b)*a is the regular expression that denotes L<sub>2</sub>.</p>
  <p>- L<sub>1</sub> &cup; L<sub>2</sub> is denoted by the regular expression a(a+b)* + (a+b)*a. Therefore,
  L<sub>1</sub> &cup; L<sub>2</sub> is regular.</p>
</ul>

<p>In terms of DFA, we can say that a DFA(L<sub>1</sub> &cup; L<sub>2</sub>) accepts those strings that 
are accepted by either DFA(L<sub>1</sub>) or DFA(L<sub>2</sub>) or both.</p>
<ul>
  <li>DFA(L<sub>1</sub> &cup; L<sub>2</sub>) can be constructed by adding a new start state and new final 
  state.</li>
  <li>The new start state connects to the two start states of DFA(L<sub>1</sub>) and DFA(L<sub>2</sub>) 
  by  &epsilon;transitions.</li>
  <li>Similarly, two &epsilon; transitions are added from the final states of DFA(L<sub>1</sub>) and
  DFA(L<sub>2</sub>) to the new final state.
  <li>Convert this resulting NFA to its equivalent DFA.</li>
</ul>
<p>As an exercise you can try this approach of DFA construction for union for the given example.</p>

<p><b>CONCLUSION: REGULAR LANGUAGES ARE CLOSED UNDER UNION.</b></p>

<h3>3. Intersection</h3>

<p><b style="color: blue">If L<sub>1</sub> and L<sub>2</sub> are regular, then L<sub>1</sub> &cap;
L<sub>2</sub> is regular.</b></p>

<p>Since a language denotes a set of (possibly infinite) strings and we have shown above that regular
languages are closed under union and complementation, by De Morgan's law can be applied to show that
regular languages are closed under intersection too.</p>

<p>L<sub>1</sub> and L<sub>2</sub> are regular &rArr; L<sub>1</sub>' and L<sub>2</sub>' are regular
(by Complementation property)<br>
&emsp; &emsp; &emsp; &emsp; &emsp; L<sub>1</sub>' &cup; L<sub>2</sub>' is regular (by Union property)<br>
&emsp; &emsp; &emsp; &emsp; &emsp; L<sub>1</sub> &cap; L<sub>2</sub> is regular (by De Morgan's law)</p>

<p>In terms of DFA, we can say that a DFA(L<sub>1</sub> &cap; L<sub>2</sub>) accepts those strings that 
are accepted by both DFA(L<sub>1</sub>) and DFA(L<sub>2</sub>).</p>

<p><b>CONCLUSION: REGULAR LANGUAGES ARE CLOSED UNDER INTERSECTION.</b></p>

<h3>4. Concatenation</h3>

<p><b style="color: blue">If L<sub>1</sub> and L<sub>2</sub> are regular, then L<sub>1</sub> .
L<sub>2</sub> is regular.</b></p>

<p>This can be easily proved by regular expressions. If R1 is a regular expression denoting L<sub>1</sub>
and R2 is a regular expression denoting L<sub>2</sub>, then we  R1 . R2 denotes the regular expression 
denoting L<sub>1</sub> . L<sub>2</sub>. Therefore, L<sub>1</sub> . L<sub>2</sub> is regular.</p>

<p>In terms of DFA, we can say that a DFA(L<sub>1</sub> . L<sub>2</sub>) can be constructed by adding an
&epsilon;-trainstion from the final state of DFA(L<sub>1</sub>) - which now ceases to be the final state -
to the start state of DFA(L<sub>2</sub>). You can try showing this using an example.</p>

<p><b>CONCLUSION: REGULAR LANGUAGES ARE CLOSED UNDER CONCATENATION.</b></p>

<h3>5. Kleene star</h3>

<p><b style="color: blue">If L is regular, then L* is regular.</b></p>

<p>This can be easily proved by regular expression. If L is regular, then there exists a regular expression
R. We know that if R is a regular expression, R* is a regular expression too. R* denotes the language L*.
Therefore L* is regular.</p>

<p>In terms of DFA, in the DFA(L) we add two &epsilon; transitions, one from start state to final state and
another from final state to start state. This denotes DFA(L*). You can try showing this for an example.</p>

<p><b>CONCLUSION: REGULAR LANGUAGES ARE CLOSED UNDER KLEENE STAR.</b></p>

<h3>6. Difference</h3>

<p><b style="color: blue">If L<sub>1</sub> and L<sub>2</sub> are regular, then L<sub>1</sub> -
L<sub>2</sub> is regular.</b></p>

<p>We know that L<sub>1</sub> - L<sub>2</sub> = L<sub>1</sub> &cap; L<sub>2</sub>'</p>

<p>L<sub>1</sub> and L<sub>2</sub> are regular &rArr; L<sub>1</sub> and L<sub>2</sub>' are regular
(by Complementation property)<br>
&emsp; &emsp; &emsp; &emsp; &emsp; L<sub>1</sub> &cap; L<sub>2</sub>' is regular (by Intersection property)<br>
&emsp; &emsp; &emsp; &emsp; &emsp; L<sub>1</sub> - L<sub>2</sub> is regular (by De Morgan's law)</p>

<p>In terms of DFA, we can say that a DFA(L<sub>1</sub> - L<sub>2</sub>) accepts those strings that 
are accepted by both DFA(L<sub>1</sub>) and not accepted by DFA(L<sub>2</sub>). You can try showing this
for an example.</p>

<p><b>CONCLUSION: REGULAR LANGUAGES ARE CLOSED UNDER DIFFERENCE.</b></p>

<h3>7. Reverse</h3>

<p><b style="color: blue">If L is regular, then L<sup>R</sup> is regular.</b></p>

<p>Let DFA(L) denote the DFA of L. Make the following modifications to construct DFA(L<sup>R</sup>).</p>
<ol>
  <li>Change the start state of DFA(L) to the final state.</li>
  <li>Change the final state of DFA(L) to the start state.</li>
  <p> In case there are more than one final state in DFA(L), first add a new final state and add &epsilon;-
  transitions from the final states (which now cease to be final states any more) and perform this step.</li>
  <li>Reverse the direction of the arrows.</li>
</ol>
<p>You can try showing this using an example.</p>

<p><b>CONCLUSION: REGULAR LANGUAGES ARE CLOSED UNDER REVERSAL.</b></p>


<h2>(B) Decision Properties</h2>

<h3>1. Membership question</h3>

<p><b style="color: blue">Does a string w belong to L? i.e. Is w &in; L?</b></p>

<p>This can be validated as follows.</p>
<ul>
  <li>Construct DFA(L).</li>
  <li>Run w on DFA(L).</li>
  <li>If DFA(L) accepts w, then w &in; L. Else w &notin; L.</li>
</ul>

<p><b>CONCLUSION: MEMBERSHIP QUESTION IN REGULAR LANGUAGES IS DECIDABLE.</b></p>

<h3>2. Emptiness question</h3>

<p style="color: blue">Is L = &phi;?</p>

<p>This can be validated as follows.</p>
<ul>
  <li>Construct DFA(L).</li>
  <li>If there exists no path from start state to final state, L = &phi;. Else L &ne; &phi;.</li>
</ul>

<p><b>CONCLUSION: EMPTINESS OF REGULAR LANGUAGES IS DECIDABLE.</b></p>

<h3>3. Equivalence question</h3>

<p style="color: blue">Is L<sub>1</sub> = L<sub>2</sub>?</p>

<p>This can be validated as follows.</p>
<ul>
  <li>Construct DFA(L<sub>1</sub>) and DFA(L<sub>2</sub>).</li>
  <li>Reduce them to their minimal DFAs: MinDFA(L<sub>1</sub>) and MinDFA(L<sub>2</sub>).</li>
  <li>If MinDFA(L<sub>1</sub>) = MinDFA(L<sub>2</sub>) then L<sub>1</sub> = L<sub>2</sub>.
  Else L<sub>1</sub> &ne; L<sub>2</sub>.</li>
</ul>

<p><b>CONCLUSION: EQUIVALENCE OF REGULAR LANGUAGES IS DECIDABLE.</b></p>

<h3>4. Subset question</h3>

<p style="color: blue">Is L<sub>1</sub> &sub; L<sub>2</sub>?</p>

<p>This can be validated as follows.</p>
<ul>
  <li>If (L<sub>1</sub> - L<sub>2</sub>) = &phi; and (L<sub>2</sub> - L<sub>1</sub>) &ne; &phi;
  then L<sub>1</sub> &sub; L<sub>2</sub>. Else L<sub>1</sub> &nsub; L<sub>2</sub>.</li>
</ul>

<p><b>CONCLUSION: SUBSET PROPERTY OF REGULAR LANGUAGES IS DECIDABLE.</b></p>

<h3>5. Infinite question</h3>

<p style="color: blue">Is L infinite?</p>

<p>This can be validated as follows.</p>
<ul>
  <li>Construct DFA(L).</li>
  <li>If DFA(L) has at least one loop, then L is infinite. Else L finite.</li>
</ul>

<p><b>CONCLUSION: INFINITE PROPERTY OF REGULAR LANGUAGES IS DECIDABLE.</b></p>

    </div>
  </div>

  <div id="navigation">
  <p><br><strong><a href="../index.html">Home</a></strong></p>
    <ul>
      <li><a href="fsm.html">Finite State Machines</a></li>
      <li><a href="dfa.html">Deterministic Finite Automata (DFA)</a></li>
      <li><a href="dfaapplications.html">DFA Applications</a></li>
      <li><a href="dfaminimization.html">DFA Minimization</a></li>
      <li><a href="nfa.html">Non-deterministic Finite Automata (NFA)</a></li>
      <li><a href="nfadfa.html">NFA - DFA Equivalence</a></li>
      <li><a href="regex.html">Regular Expressions</a></li>
      <li><a href="regexnfa.html">Regexp - NFA Equivalence</a></li>
      <li><a href="regulargrammar.html">Regular Grammar (RG)</a></li>
      <li><a href="rgnfa.html">RG - NFA Equivalence</a></li>
      <li><a href="rlproperties.html">Properties of Regular Languages</a></li>
      <li><a href="pumpinglemma.html">Pumping Lemma for Regular Languages</a></li>
      <li><a href="lexer.html">FSM Application: Lexical Analysis</a></li>
      <li><a href="jlex.pdf">JLex: A Lexical Analyzer Generator</a></li>
  </div>

  <div id="extra">
  </div>
  <div id="footer", align="right">
    <p>Send your suggestions/comments to swaminathanj@am.amrita.edu</p>
  </div>
</div>
</body>
</html>

</body>
